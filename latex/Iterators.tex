 %auto-ignore
\subsection{Iterators and Iterating Velocity}
 

  Iterator is an operator, composing a program $p:\VV\to \VV\in\dP$ with itself. For ease of expression, we denote the $n$-th iterate of a program $p\in\dP$, as $p^n$, as it is possible to view iteration as compositional exponentiation. In this view, one may seek to explore the relation between the value of the $n$-th iterate and $n$. With a form which expresses the iterate as a function of $n$, one could inquire its rate of change in relation to it and investigate fractional iterations, akin to fractional powers of other operators \cite{komatsu1966fractional}.
  
Let $\mathcal{I}_p$ be the monoid under composition $\circ$ 
  \begin{equation}\label{eq:iter_def}
  \mathcal{I}_p=\{p^n:\VV\to \VV;\quad p\left(\vv_f\right)=\vv_f\},
  \end{equation}
  generated by $p\in\dP:\VV\to \VV$ with some fixed point $\vv_f\in \VV$; note that any terminating program has a fixed point. We than turn towards analysing the structure of \eqref{eq:iter_def} in relation to $n$, the number of iterations.

Let $\mathcal{C}_p:h\to h\circ p$ be the operator of composition with $p$ and assume $h$ to be the solution of the eigen equation
\begin{equation}\label{eq:kh}
  \mathcal{C}_p(h)=\Lambda \cdot h\iff h\left(p\left(\vv\right)\right)=\Lambda\cdot h\left(\vv\right).
  \end{equation}
It is clear that the composition of $h$ with $p^n$ is such, 
  \begin{equation} 
  h\left(p^n\left(\vv\right)\right)=\Lambda^n\cdot h\left(\vv\right)
  \end{equation}
that in the image of $h$, iterations of $p$ become multiplication with the eigen matrix $\Lambda$. This allows us to generalize the notion of an iteration from the integers, $n\in\mathbb{N}$, to the reals, $x\in\mathbb{R}$, and consider fractional iterations by
\begin{equation}
  p^x\left(\vv\right)=h^{-1}\left(\Lambda^x\cdot h\left(\vv\right)\right),
\end{equation}
assuming $h^{-1}$ exists. Note that we can express the eigen matrix $\Lambda$ by differentiating $\eqref{eq:kh}$ at the fixed point $\vv_f$,
$$\D h\left(p\left(\vv_f\right)\right)\cdot\D p\left(\vv_f\right)=\Lambda\cdot\D h\left(\vv_f\right)\implies\D p\left(\vv_f\right)=\Lambda.$$

With foundations established, we can proceed to inquire about the rate of change of the values of a program $p$ in relation to $n$, the number of iterations. Lets define the \emph{rate of change operator} $\Psi$ 
  \begin{equation}
    \Psi:p^n\to\D_np^n,
  \end{equation}
that maps an iterate $p^n$ to its \emph{iterating velocities} $\D_n p^n$. Of course
  \begin{equation}
  \Psi\left(p^n\right)\left(\vv_f\right)=0,
  \end{equation}
the iterating velocities of any iterate at the fixed point $\vv_f$ are constantly zero, which is deduced from the $\eqref{eq:kh}$ and reassures our intuition. Next, we introduce a change of variables $\Lambda= e^\nu$ for mathematical convenience and proceed towards computing the iterating velocity.
  $$\D_nh\left(p^n\right)=\D_n\left(e^{\nu n}\cdot h\right)$$
  $$\implies$$
  $$\D h\left(p^n\right)\cdot\D_np^n=\nu\cdot e^{\nu n}\cdot h \land e^{\nu n}\cdot h=h\left(p^n\right)$$
  $$\implies$$
  \begin{equation}\label{eq:iter_vel}
  \Psi=\nu\cdot(\D h)^{-1}\cdot h
  \end{equation}
The rate of change operator $\Psi$ and iterating velocities
\footnote{Higher derivatives can be derived by induction.}
\eqref{eq:iter_vel} can be used to study iterated processes, which feature prominently in machine learning; ex. examine the importance of continued iteration and aid decisions on early stopping.

The computation of the eigen map $h$ \eqref{eq:kh} was solved by Bridges \cite{bridges2016solution} for any $p$ with a power series representation. This result is extended to tensor series by the isomorphism to their quotient. Hence, as we can expand any $p\in\dP$ into a tensor series by the use of the operator $e^\D$, by Theorem $\ref{izr:e^d}$ the result also holds for any $p\in\dP$. 


\subsection{ReduceSum in the Language of Operational Calculus}

As a demonstration of the algebraic power over analytic conclusions inherent to our model, we examine the functional \emph{ReduceSum}, and derive its explicit form as a function of $n$, the number of its iterations, or upper bound, with special interest in the rate of change of the functional in relation to $n$; i.e. iterating velocity and its higher order counter parts (acceleration etc.). 

Let $\mathcal{S}^n$ denote the operator, that performs a linear shift of a program $p$ in the direction $\vv$, from its initial point $\vv_0$. By Theorem $\ref{izr:e^d}$ we have
  \begin{equation}\label{eq:sn=ed}
    \left(e^{n\D}\vert_{\vv_0}p\right)(\vv)=p(\vv_0+n\vv)\implies \mathcal{S}^n=e^{n\D}\vert_{\vv_0},
  \end{equation}
and thus clearly $\mathcal{S}^n\cdot\mathcal{S}^m=\mathcal{S}^{n+m}$ and $(\mathcal{S}^n+\mathcal{S}^m)(p)=\mathcal{S}^n(p)+\mathcal{S}^m(p)$, which we use to define the $n$-th reduction as
$$\mathcal{R}_+^n=(1+\mathcal{S}+\mathcal{S}^2+\cdots+\mathcal{S}^n),$$
that results in
   $$\mathcal{R}^n_+(p)(\vv)=\sum\limits_{h=0}^{n}p(\vv_0+h\vv)$$
upon application.

With this we turn towards computing with operators alone to harness the algebraic power of our framework. We write
$$(1+\mathcal{S}+\mathcal{S}^2+\cdots+\mathcal{S}^n)=1+\mathcal{S}(1+\mathcal{S}+\mathcal{S}^2+\cdots+\mathcal{S}^{n-1})$$
   $$\implies$$
   $$1-\mathcal{S}^n=\left(1-S\right)\mathcal{R}^{n-1}_+$$
   $$\implies$$
  \begin{equation}
\mathcal{R}^{n-1}_+=\left(1-\mathcal{S}^n\right)\left(\frac{1}{1-\mathcal{S}}\right),
  \end{equation}
where $\frac{1}{1-\Ss}$ is to be understood in the sense of formal tensor series. We will denote $(1-\mathcal{S}^n)$ by $\Big[\cdot\Big]^n_{\vv_0}$, recognizing that it represents the action of shifting the program in the direction of $\vv$ by a fraction of $n$, from its initial position $\vv_0$, and subtracting the two; while $\vv$ is yet to be applied. Taking Theorem \ref{izr:e^d} into account we write
  \begin{equation}\label{eq:Rn+Basic}
    \mathcal{R}^{n-1}_+=\Bigg[\D^{-1}\left(\frac{\D}{1-e^\D}\right)\Bigg]^n_{\vv_0}.
  \end{equation}
Note that while $\D^{-1}$ is undetermined, its composition with $\Big[\cdot\Big]^n_{\vv_0}$ is well defined on $\VV\otimes\T(\VV^*)$.
Also note, that the parenthesised expression, $\frac{\D}{1-e^\D}$, and $\D^{-1}$ are algebraic encodings of higher-order programs, which are to be expanded into explicit form upon application inside the tensor series algebra of the programming space $\dP\otimes \T(\VV^*)$. Doing so, we recognize
\begin{equation}
    	\frac{h\D}{1-e^{h\D}}=\sum\limits_{i=0}^{\infty}B_i\frac{(h\D)^i}{i!}
    \end{equation}
$B_i$ to be the $n$-th Bernoulli number. Thus the higher order program
$$\mathcal{R}^{n-1}_+:\dP\to\Big\{\VV\to \VV\otimes \T(\VV^*)\Big\}$$
is expressed as 
    \begin{equation}\label{eq:Rn+}
      \mathcal{R}^{n-1}_+=\Bigg[B_0\D^{-1}+\sum\limits_{i=1}^{\infty}B_i\frac{\D^{i-1}}{i!}\Bigg]_{\vv_0}^{n}.
    \end{equation}
Upon applying it to a program at a particular point $\vv\in \VV$ this becomes
\begin{equation}\label{eq:Rn+P}
  \mathcal{R}^{n-1}_+p(\vv)=\Bigg[B_0\D^{-1}p(t)+\sum\limits_{i=1}^{\infty}B_i\frac{\D^{i-1}p(t)}{i!}\Bigg]_{\vv_0}^{n\vv} \Big(\vv\Big),
    \end{equation}
where the evaluation at $\vv\in \VV$ as by \eqref{eq:polynomial_tensor}, performs the needed translation
\footnote{Both the translation and the shift are to be performed (at) by the same point $\vv\in\VV$.},
as the image of the operator $\mathcal{R}^{n-1}_+$ is an element of the tensor series algebra of the memory space $\VV\otimes \T(\VV^*)$.
Note that $n$, the number of iterations, is the only remaining free variable, as desired.
\begin{remark}
  When $p\in\dP$ is an univariate mapping, the expression \eqref{eq:Rn+P} recovers the Euler-Maclaurin integral formula \cite{apostol1999elementary}, which is demonstrated by applying the operator \eqref{eq:Rn+} to the function $x^m$
$$\mathcal{R}^n_+(x^m)=\frac{1}{m+1}\sum_{i=0}^m{m+1\choose i}B_i\cdot n^{m+1-i},$$
and producing the closed form solution.
\end{remark}
Furthermore, due to the operational algebra of higher order programs established by our model, we can compute the operator of iterating velocity (and higher order change) of the $n$-th iterate by differentiating the operator $\mathcal{R}^{n-1}_+$ itself. Reverting to the form \eqref{eq:Rn+Basic} and substituting \eqref{eq:sn=ed}, we have
\begin{equation}
  \frac{d^k}{dn^k}\mathcal{R}^{n-1}_+=\frac{d^k}{dn^k}\left(\left(1-e^{n\D}\right)\left(\frac{1}{1-e^\D}\right)\right)=\mathcal{S}^n\left(\frac{\D^n}{1-e^\D}\right),
   \end{equation}
where commutativity of shifting and differentiating was used. Noting that $\mathcal{S}^n$ simply shifts the operand in the direction of $\vv$ by a factor of $n$, the explicit form 
\begin{equation}
        \frac{d^k}{dn^k}\mathcal{R}^{n-1}_+\dP\vert_{n=N}(\vv)=\left(\sum\limits_{i=0}^{\infty}B_i\frac{\D^{N-1+i}\dP\left(\vv_0+N\vv\right)}{i!}\right)\Big(\vv\Big)
        \end{equation}
where the evaluation at $\vv\in \VV$ once again performs the needed translation.

